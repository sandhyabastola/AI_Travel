# # -*- coding: utf-8 -*-
# """recommendationmodel.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1PrbbOpiY1HWnwE9sIJNV-pjRquj5pN2p
# """

# #from google.colab import files
# #uploaded = files.upload()

# import numpy as np
# import pandas as pd
# import re
# import math

# class ContentBasedRecommendationSystem:
#     def __init__(self):
#         self.df = None
#         self.feature_matrix = None

#     def load_dataset(self, csv_file):
#         self.df = pd.read_csv(csv_file)
#         self.df.fillna('', inplace=True)

#     def preprocess_text(self, text):
#         text = text.lower()
#         text = re.sub(r'[^a-z\s]', '', text)
#         return text

#     def tokenize(self, text):
#         return text.split()

#     def compute_tf_idf(self, corpus):
#         N = len(corpus)
#         vocab = {}
#         df = {}
#         tf_idf_matrix = []

#         # Vocabulary and document frequency
#         for text in corpus:
#             words = self.tokenize(self.preprocess_text(text))
#             word_counts = {}
#             for word in words:
#                 if word not in vocab:
#                     vocab[word] = len(vocab)
#                 word_counts[word] = word_counts.get(word, 0) + 1
#             for word in set(words):
#                 df[word] = df.get(word, 0) + 1

#         # TF-IDF
#         for text in corpus:
#             words = self.tokenize(self.preprocess_text(text))
#             word_count = {}
#             for word in words:
#                 word_count[word] = word_count.get(word, 0) + 1

#             tf_idf = [0] * len(vocab)
#             for word in words:
#                 tf = word_count[word] / len(words)
#                 idf = math.log((N + 1) / (df[word] + 1)) + 1
#                 tf_idf[vocab[word]] = tf * idf
#             tf_idf_matrix.append(tf_idf)

#         return np.array(tf_idf_matrix), list(vocab.keys())

#     def build_feature_matrix(self):
#         tfidf_matrix, tfidf_vocab = self.compute_tf_idf(self.df['description'].tolist())

#         # One-hot encode categorical features
#         style_encoded = pd.get_dummies(self.df['travel_style'])
#         weather_encoded = pd.get_dummies(self.df['weather'])
#         budget_encoded = pd.get_dummies(self.df['budget_level'])

#         # Combine features
#         self.feature_matrix = np.hstack((
#             tfidf_matrix,
#             style_encoded.values,
#             weather_encoded.values,
#             budget_encoded.values
#         ))

#         self.columns = tfidf_vocab + list(style_encoded.columns) + list(weather_encoded.columns) + list(budget_encoded.columns)

#     def train(self, csv_file):
#         self.load_dataset(csv_file)
#         self.build_feature_matrix()

#     def get_recommendations(self, user_input, top_k=5):
#         if self.feature_matrix is None:
#             raise Exception("Model not trained yet.")

#         user_vector = np.zeros(self.feature_matrix.shape[1])
#         for i, col in enumerate(self.columns):
#             if (col == user_input['style']) or (col == user_input['weather']) or (col == user_input['budget_level']):
#                 user_vector[i] = 1
#             if col in user_input.get('keywords', []):
#                 user_vector[i] = 1

#         def cosine_similarity(v1, v2):
#             dot = np.dot(v1, v2)
#             norm1 = np.linalg.norm(v1)
#             norm2 = np.linalg.norm(v2)
#             return dot / (norm1 * norm2 + 1e-10)

#         scores = []
#         for idx, place_vec in enumerate(self.feature_matrix):
#             sim = cosine_similarity(user_vector, place_vec)
#             scores.append((idx, sim))

#         scores = sorted(scores, key=lambda x: x[1], reverse=True)[:top_k]

#         recommendations = []
#         for rank, (idx, score) in enumerate(scores, 1):
#             place = self.df.iloc[idx]
#             recommendations.append({
#                 'rank': rank,
#                 'name': place['name'],
#                 'travel_style': place['travel_style'],
#                 'weather': place['weather'],
#                 'budget_level': place['budget_level'],
#                 'description': place['description'],
#                 'img_url': place['img_url'],
#                 'similarity_score': score
#             })

#         return recommendations

# recommender = ContentBasedRecommendationSystem()
# recommender.train('nepal-dataset.csv')  # your 100-row dataset

# user_preferences = {
#     'style': 'cultural',
#     'weather': 'cold',
#     'budget_level': 'medium',
#     'keywords': ['temple']
# }

# recommendations = recommender.get_recommendations(user_preferences, top_k=5)

# from IPython.display import Image, display
# # Display results with actual images in Google Colab


# for r in recommendations:
#     print(f"{r['rank']}. {r['name']} (Score: {r['similarity_score']:.3f})")
#     print(f"   Style: {r['travel_style']} | Weather: {r['weather']} | Budget: {r['budget_level']}")
#     print(f"   Description: {r['description'][:100]}...")

#     # Display image
#     print("   Image:")
#     display(Image(url=r['img_url'], width=300))  # You can change width as needed

#     print("\n" + "-"*80 + "\n")

# from IPython.display import Image, display

# for r in recommendations:
#     print(f"{r['rank']}. {r['name']} (Score: {r['similarity_score']:.3f})")
#     print(f"   Description: {r['description'][:100]}...")
#     display(Image(url=r['img_url'], width=300))
#     print()
import pandas as pd

def get_recommendations(user_input, from_location=None, to_location=None, hotel_location=None, travel_category=None):
    # Load datasets
    destination_df = pd.read_csv("nepal_destination.csv")
    hotel_df = pd.read_csv("nepal_hotel.csv")
    transport_df = pd.read_csv("nepal_transport_dataset.csv")
    travel_df = pd.read_csv("nepal_travel_dataset.csv")

    recommendations = {}

    # ===== üèîÔ∏è Destination Recommendations =====
    for tag in ['adventure', 'nature', 'culture']:
        if tag not in destination_df.columns:
            destination_df[tag] = destination_df['Type'].str.contains(tag, case=False, na=False)

    dest_filtered = destination_df[destination_df[['adventure', 'nature', 'culture']].any(axis=1)]

    if not dest_filtered.empty:
        dest_top = dest_filtered.head(3)
        recommendations["destinations"] = dest_top[["Destination Name", "Description"]].to_dict(orient="records")
    else:
        recommendations["destinations"] = [{"message": "üòï No destinations found matching your interest."}]

    # ===== üè® Hotel Recommendations =====
    if hotel_location:
        hotel_filtered = hotel_df[hotel_df['Location'].str.contains(hotel_location, case=False, na=False)]
    else:
        hotel_filtered = hotel_df

    if not hotel_filtered.empty:
        hotel_top = hotel_filtered.sort_values(by="Rating", ascending=False).head(3)
        recommendations["hotels"] = hotel_top[["Hotel Name", "Location", "Rating"]].to_dict(orient="records")
    else:
        recommendations["hotels"] = [{"message": "‚ùå No hotels found for the specified location."}]

    # ===== üöê Transport Recommendations =====
    if from_location and to_location:
        transport_filtered = transport_df[
            (transport_df['From'].str.contains(from_location, case=False, na=False)) &
            (transport_df['To'].str.contains(to_location, case=False, na=False))
        ]
    else:
        transport_filtered = transport_df

    if not transport_filtered.empty:
        transport_top = transport_filtered.head(3)
        recommendations["transport"] = transport_top[["From", "To", "Transport Type", "Estimated Time", "Price"]].to_dict(orient="records")
    else:
        recommendations["transport"] = [{"message": "‚ùå No transport routes found."}]

    # ===== ‚úàÔ∏è Travel Tips / Info Recommendations =====
    if travel_category:
        travel_filtered = travel_df[travel_df['Category'].str.contains(travel_category, case=False, na=False)]
    else:
        travel_filtered = travel_df

    if not travel_filtered.empty:
        travel_top = travel_filtered.head(3)
        recommendations["travel"] = travel_top[["Title", "Category", "Summary"]].to_dict(orient="records")
    else:
        recommendations["travel"] = [{"message": "‚ùå No travel info available."}]

    return recommendations
